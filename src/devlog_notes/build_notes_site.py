from __future__ import annotations

import re
import shutil
from collections.abc import Iterable
from dataclasses import dataclass
from datetime import date
from pathlib import Path

from jinja2 import Environment, FileSystemLoader, select_autoescape
from markdown_it import MarkdownIt

PACKAGE_DIR = Path(__file__).resolve().parent
REPO_ROOT = Path(__file__).resolve().parents[2]
PACKAGE_TEMPLATES_DIR = PACKAGE_DIR / "templates"


def _first_existing(candidates: Iterable[Path]) -> Path | None:
  for candidate in candidates:
    if candidate.exists():
      return candidate
  return None


def _resolve_notes_dir() -> Path:
  cwd = Path.cwd()
  if (cwd / "notes").is_dir():
    return cwd / "notes"
  if any(cwd.glob("*.md")):
    return cwd
  if (REPO_ROOT / "notes").is_dir():
    return REPO_ROOT / "notes"
  return cwd / "notes"


def _resolve_templates_dir() -> Path:
  resolved = _first_existing([Path.cwd() / "templates", PACKAGE_TEMPLATES_DIR, REPO_ROOT / "templates"])
  if resolved is None:
    raise RuntimeError("No templates directory found for devlog-notes")
  return resolved


NOTES_DIR = _resolve_notes_dir()
TEMPLATES_DIR = _resolve_templates_dir()
SITE_DIR = Path.cwd() / "site"
ASSETS_DIR = SITE_DIR / "assets"

CSS_CONTENT = """/* Generated by build_notes_site.py */
:root {
  --bg: #f6f4ef;
  --surface: #fffdf9;
  --text: #202022;
  --muted: #5a5a66;
  --accent: #0f6a64;
  --accent-soft: #e2f2ef;
  --border: #d8d5cf;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
  background: radial-gradient(circle at top right, #ece7db, var(--bg) 35%);
  color: var(--text);
  line-height: 1.6;
}

a {
  color: var(--accent);
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

.container {
  max-width: 860px;
  margin: 0 auto;
  padding: 2rem 1.1rem 3rem;
}

header {
  margin-bottom: 1.5rem;
}

h1,
h2,
h3 {
  line-height: 1.2;
  margin-top: 0;
}

.card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 1rem 1.1rem;
  margin-bottom: 0.8rem;
}

.meta {
  color: var(--muted);
  font-size: 0.95rem;
  margin-bottom: 0.3rem;
}

nav {
  margin-bottom: 1.2rem;
}

nav a {
  margin-right: 1rem;
}

article {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 1.1rem;
}

.feed-entry {
  margin-bottom: 2rem;
}

.feed-entry article {
  margin-top: 0.6rem;
}

.feed-entry + .feed-entry {
  padding-top: 1.2rem;
  border-top: 1px solid var(--border);
}

hr {
  border: none;
  border-top: 1px solid var(--border);
  margin: 1.25rem 0;
}
"""


@dataclass
class Note:
  slug: str
  note_date: date
  title: str
  excerpt: str
  html: str


def _extract_title(markdown: str, fallback: str) -> str:
  for line in markdown.splitlines():
    if line.startswith("# "):
      return line[2:].strip() or fallback
  return fallback


def _extract_excerpt(markdown: str) -> str:
  lines = markdown.splitlines()
  chunk: list[str] = []
  for line in lines:
    stripped = line.strip()
    if not stripped:
      if chunk:
        break
      continue
    if stripped.startswith("#"):
      continue
    if stripped.startswith("-"):
      continue
    chunk.append(stripped)
  excerpt = " ".join(chunk)
  excerpt = re.sub(r"`([^`]*)`", r"\1", excerpt)
  excerpt = re.sub(r"\[(.*?)\]\(.*?\)", r"\1", excerpt)
  return excerpt[:220] + ("..." if len(excerpt) > 220 else "")


def _read_notes(md: MarkdownIt) -> list[Note]:
  notes: list[Note] = []
  if not NOTES_DIR.exists():
    return notes

  for path in sorted(NOTES_DIR.glob("*.md")):
    slug = path.stem
    try:
      parsed_date = date.fromisoformat(slug)
    except ValueError:
      print(f"Skipping {path.name}: expected YYYY-MM-DD.md")
      continue

    raw = path.read_text(encoding="utf-8")
    title = _extract_title(raw, slug)
    excerpt = _extract_excerpt(raw)
    html = md.render(raw)
    notes.append(Note(slug=slug, note_date=parsed_date, title=title, excerpt=excerpt, html=html))

  notes.sort(key=lambda note: note.note_date, reverse=True)
  return notes


def _render_templates(notes: list[Note]) -> None:
  env = Environment(
    loader=FileSystemLoader(str(TEMPLATES_DIR)),
    autoescape=select_autoescape(["html", "xml"]),
    trim_blocks=True,
    lstrip_blocks=True,
  )

  index_template = env.get_template("index.html")
  archive_template = env.get_template("archive.html")
  note_template = env.get_template("note.html")

  recent = notes[:5]
  (SITE_DIR / "index.html").write_text(index_template.render(notes=recent), encoding="utf-8")

  archive_dir = SITE_DIR / "archive"
  archive_dir.mkdir(parents=True, exist_ok=True)
  (archive_dir / "index.html").write_text(archive_template.render(notes=notes), encoding="utf-8")

  notes_root = SITE_DIR / "notes"
  for note in notes:
    note_dir = notes_root / note.slug
    note_dir.mkdir(parents=True, exist_ok=True)
    (note_dir / "index.html").write_text(note_template.render(note=note), encoding="utf-8")


def _write_assets() -> None:
  ASSETS_DIR.mkdir(parents=True, exist_ok=True)
  (ASSETS_DIR / "styles.css").write_text(CSS_CONTENT, encoding="utf-8")


def main() -> None:
  md = MarkdownIt("commonmark")

  if SITE_DIR.exists():
    shutil.rmtree(SITE_DIR)
  SITE_DIR.mkdir(parents=True, exist_ok=True)

  notes = _read_notes(md)
  _render_templates(notes)
  _write_assets()

  print(f"Built {len(notes)} notes into {SITE_DIR}")


if __name__ == "__main__":
  main()
